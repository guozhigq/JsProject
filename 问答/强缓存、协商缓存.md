<!--
 * @Author: guozhigq
 * @Date: 2021-11-19 20:07:14
 * @LastEditTime: 2021-11-20 11:55:18
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /JsProject/问答/强缓存、协商缓存.md
-->

### 强缓存与协商缓存

#### 浏览器的缓存机制即我们所说的HTTP缓存机制，HTTP缓存机制是根据响应报文中的标识来进行的

一般的，当我们通过浏览器来向HTTp服务器发起请求获取资源，当我们第一次发起时，由于本地没有缓存结果及标识，所以直接向服务端发起请求，服务器会在响应报文的HTTP头中增加缓存标识，客户端即浏览器会根据缓存标识来决定是否缓存结果，需要缓存则将请求结果和缓存标识存入浏览器缓存。

所以每次在发起请求时，都会在浏览器缓存中先检查是否有请求结果以及缓存标识
根据有无请求结果及缓存标识，做以下判断：
1. 无缓存结果和缓存标识，走强制缓存失败，直接向服务器发起请求
2. 有缓存结果和缓存标识
   1. 缓存标识在有限期内，强制缓存生效，直接返回缓存结果，此时网球请求显示灰色的200
   2. 缓存标识已失效，则走协商缓存

### 强缓存

在浏览器向服务器发起请求时，服务器会在响应报文中返回强缓存标识字段：
+ http 1.0 时返回的Expiress
+ http 1.1 时返回Cache-Control

Cache-Control 优先级高于Expiress

#### Expiress 绝对时间

Expiress中存有服务器返回的当前请求结果缓存的到期时间，即再发起请求时，如果当前客户端时间小于该时间，直接使用缓存结果。但是是又客户端时间与服务端时间做对比，容易因为时间不准备产生误差，导致强缓存失效，那么Cache-Control又做了哪些改进呢

#### Cache-Control

在http 1.1中，控制强缓存的标识改为了Cache-Control，主要根据以下几个字段进行取值：
+ public 所有内容都将被缓存 客户端和服务器都可缓存
+ private 所有内容只有客户端可以缓存 默认值
+ no-cache 客户端缓存内容，但是是否使用缓存需要经过协商缓存来决定
+ no-store 所有内容都不会被缓存，强缓存和协商缓存都不走
+ max-age 缓存内容将在n秒后失效，相对时间

#### 缓存位置

强缓存


### 协商缓存

如果本地强缓存标识失效，则走协商缓存：
携带缓存标识向服务器发起请求来确定是否继续使用本地缓存结果
+ 协商缓存失败，返回200和请求结果
+ 协商缓存成功，继续使用本地缓存
  
协商缓存的标识也是在响应报文中返回的，分别有

+ 资源在服务器端的最后被修改时间：Last-Modified（响应报文中返回）  /  if-Modified-Since
+ 资源文件的唯一标识： Etag  /  if-None-Match

后者比前者优先级高

####  Last-Modified（响应报文中返回）  /  if-Modified-Since

浏览器发起协商请求时，会携带上次响应报文中所返回的Last-Modified的值来进行请求，不过此时的key变成了 if-Modified-Since，将当前资源的上次修改时间发送给服务器端，由服务器端来做判断，如果资源无效，返回200及新的请求结果。如果有效，则返回304，表示资源无更新，继续使用本地缓存结果

#### Etag  /  if-None-Match
http1.1时新增Etag

Etag是服务器端响应请求时，返回的当前资源文件的一个唯一标识

浏览器发起协商请求时，会携带上次响应报文中所返回的Etag的值来进行请求，不过此时的key变成了 if-None-Match，将当前资源的唯一标识发送给服务器端，由服务器端来与最新的资源标识做对比，如果标识不一致，返回200及新的请求结果。如果标识一效，则返回304，表示资源无更新，继续使用本地缓存结果

#### 协商缓存成功时，会更新本地强缓存标识

#### 为什么采用Etag而不是采用Last-Modified

HTTP1.1 中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题： 1、 一些文件也许会周期性的更改，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET； 2、 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是秒级的，使用 Etag 就能够保证这种需求下客户端在 1 秒内能刷新 N 次 cache。 某些服务器不能精确的得到文件的最后修改时间。




#### 强缓存状态下如何更新线上js文件

+ 文件名加时间戳/随机数，保证每次文件不一致。 每次刷新页面都会请求资源，造成浪费
+ 路径后加js版本号。
  