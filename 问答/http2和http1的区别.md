<!--
 * @Author: guozhigq
 * @Date: 2021-11-19 16:39:04
 * @LastEditTime: 2021-11-20 11:59:11
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /JsProject/问答/http2和http1的区别.md
-->

http的诞生之初是为了在网络间传递html超文本内容，所以又被称为超文本传输协议。

### http 0.9
在0.9版本的时候，只是简单的客户端请求数据+服务端返回数据的操作，不包含请求头和请求体，在服务端返回信息的时候也没有返回头信息，只返回了ASCII字节码进行页面渲染

随着网络的普及，万维网不再只是单纯了html文件传输，还包括了js、css、图片、视频的不同文件的传输，所以在1.0版本增加了对于其他类型编码文件的支持，下面介绍1.0的版本内容

### http 1.0、http 1.1介绍

为了满足多类型文件传输的需求，在1.0的时候引入了请求头和响应头，以ke-value的格式保存，在客户端发起请求时会携带请求头，在服务端响应请求时会携带响应头。

由于传输的文件数据量变大，为了提升传输性能，客户端与服务端对于传输文件进行了协商，比如文件类型、采取什么形式的压缩、文件编码格式、文件语言类型等等，都会在请求头中携带，以便告知服务端应该返回什么类型的文件数据

当服务器不能正确处理请求时，就会以状态码的形式告知客户端
为了减轻服务端的压力，在1.0的时候也提供了Catch缓存机制，用于缓存已经下载过的数据
header if-Modified-Since 
虽然1.0对于数据传输提供了很大的便利性，但是也有很多的缺陷：
+ 每发起一次请求都需要建立TCP连接，那么就需要三次握手。随着传输的文件数量越来越多，每次下次多个文件，都需要建立连接 - 传输数据 - 断开连接这样的步骤，对于服务器的消耗太大了。

于是1.0已经满足不了需求，1.1版本诞生了。
在1.1版本中，增加了持久性连接字段 Connection： keep-alive，即每次传输完数据后，并不会及时断开连接，而是在当前TCP连接上继续其他的http请求，如果客户端或者服务端没有明确断开连接，那么该TCP连接会一直保持，这样以来，减少了服务器额外的负担，也提升了网络请求的效率。

持久性连接虽然能够减少TC连接数，但是需要等待前一个请求完成之后才能进行下一次请求，所以又产生累了队头阻塞的问题。

1.1也增加了对虚拟主机的支持，随着虚拟主机技术的发展，一台物理主机上会绑定多个虚拟主机，每个虚拟主机都有自己单独的域名，因此http1.1的请求头中增加了host字段用来表示当前的域名地址


#### 总结

+ HTTP是浏览器和服务器的通信语言
+ 诞生之初的HTTP/0.9因为需求简单，所以和服务器之间的通信过程也相对简单。
+ HTTP/1.0引入了请求头和响应头，主要是为了支持多种类型的文件下载；其次，还提供了Cache机制、用户代理、 状态码等基础信息。
+ 随着技术和需求的发展，人们对文件传输的速度要求越来越高，故又基于HTTP/1.0推出了HTTP/1.1，增 加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率(不过由于各种原因，管线化技术 最终被各大厂商放弃了)。除此之外，HTTP/1.1还引入了Cookie、虚拟主机的支持、对动态内容的支持等特性。


#### 需要注意，在http 1.0与1.1所使用的缓存字段有所区别
+ 1.0 express 相对时间
+ 1.1 Cache-Control 
  + public 所有内容被缓存 客户端和代理服务器都可缓存
  + private 所有内容只有客户端可以缓存，默认值
  + no-cache 客户端缓存内容，是否使用缓存由协商缓存来验证决定
  + no-store 所有内容都不缓存，无论强缓存或者协商缓存
  + max-age 缓存内容将在n秒后失效，绝对时间



http1.1存在的问题
+ 线头阻塞 tcp连接上只能发送一个请求，前面的请求未完成时，后续的请求需要等待
+ 多个tcp连接 当发起多个请求时，会建立起多个tcp连接，每一次连接成本都比较高，还会存在慢启动问题
+ 头部冗余  每次发起请求都会携带大量相同的请求头信息，并且采用的时文本格式，首部未压缩
+ 请求必须由客户端发起，服务器不能主动发送数据

#### http 2.0

针对了1.1 2.0主要对以下方面做了优化

2.0在协议栈中新增了二进制分帧层
多路复用
    + 二进制分帧 
    + 多路复用  
    + 头部压缩 使用encoder减少需要传输的header大小，避免header重复传输
    + 服务器推送


由于多路复用，许多1.1时代的网络资源请求优化反而不起作用了

文件合并（雪碧图）

在以前会用到JS文件合并和雪碧图来减少HTTP请求的数量来达到优化目的。因为在1.1时代的TCP只能穿行复用，而现在可以多个文件并行传输。
如果一个资源a更新，由于文件a,b,c合并，本地缓存合并文件abc都需要更新。在2.0时代，不压缩文件，能更精确更新资源，反而是更好的选择

多域名

之前由于浏览器对同一个域名下TCP连接数量的限制，会把文件a，b放在两个不同的域名下，防止超过TCP最大连接数量的HTTP请求被阻塞。 但由于多路复用，放在同一个域名下ab文件可以被同时下载，并且减少对多个域名建立TCP连接的时间浪费。